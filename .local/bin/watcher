#!/usr/bin/env bash

if [[ $# -eq 0 ]]; then
    echo "Usage: $0 <command> [args...]" >&2
    exit 1
fi

# Function to check if a file should be ignored based on .gitignore
should_ignore() {
    local file="$1"
    
    # Use git check-ignore if we're in a git repo
    if git rev-parse --git-dir >/dev/null 2>&1; then
        git check-ignore "$file" >/dev/null 2>&1
        return $?
    fi
    
    # If not in git repo, check for .gitignore manually
    if [[ -f .gitignore ]]; then
        # Simple pattern matching - this is basic but covers most cases
        while IFS= read -r pattern; do
            # Skip empty lines and comments
            [[ -z "$pattern" ]] && continue
            case "$pattern" in '#'*) continue ;; esac
            
            # Remove leading/trailing whitespace
            pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # Convert gitignore pattern to shell pattern
            case "$pattern" in
                */)
                    # Directory pattern
                    case "$file" in ${pattern%/}*) return 0 ;; esac
                    ;;
                */*)
                    # Path with slash
                    [[ "$file" == $pattern ]] && return 0
                    ;;
                *)
                    # Simple pattern
                    [[ "$(basename "$file")" == $pattern ]] && return 0
                    ;;
            esac
        done < .gitignore
    fi
    
    return 1
}

# Get initial file list
get_files() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        # In git repos: combine tracked files and untracked files, exclude ignored
        {
            git ls-files 2>/dev/null
            git ls-files --others --exclude-standard 2>/dev/null
        } | sort -u
    else
        # Fallback to find with basic filtering
        find . -type f -not -path './.git/*' -not -name '.*' 2>/dev/null | sort
    fi
}

echo "Starting watcher for command: $*"
echo "Monitoring directory: $(pwd)"

# Get initial state
current_files=$(get_files)
current_count=$(echo "$current_files" | wc -l)
echo "Initial file count: $current_count"

# Start the command
command_pid=""
start_command() {
    if [[ -n "$command_pid" ]]; then
        echo "🔄 Stopping previous command (PID: $command_pid)"
        kill -TERM "$command_pid" 2>/dev/null
        wait "$command_pid" 2>/dev/null
    fi
    
    echo "🚀 Starting command: $*"
    echo "----------------------------------------"
    "$@" &
    command_pid=$!
    echo "Command started with PID: $command_pid"
}

# Start initial command
start_command "$@"

# Watch for changes
echo "Watching for new files... (Press Ctrl+C to stop)"
echo ""

while true; do
    # Interruptible sleep - sleep in background and wait for it
    sleep 1 &
    sleep_pid=$!
    wait $sleep_pid 2>/dev/null || break
    
    # Always check for file changes first
    new_files=$(get_files)
    new_count=$(echo "$new_files" | wc -l)
    
    # Debug output
    if [[ $WATCHER_DEBUG == "1" ]]; then
        echo "DEBUG: Current count: $current_count, New count: $new_count"
    fi
    
    if [[ "$new_files" != "$current_files" ]]; then
        echo ""
        echo "📁 File change detected! ($current_count -> $new_count files)"
        
        # Show what changed
        if [[ $new_count -gt $current_count ]]; then
            echo "📄 New files:"
            comm -13 <(echo "$current_files") <(echo "$new_files") | head -5 | sed 's/^/  /'
            [[ $new_count -gt $((current_count + 5)) ]] && echo "  ... and $((new_count - current_count - 5)) more"
        elif [[ $new_count -lt $current_count ]]; then
            echo "🗑️  Removed files:"
            comm -23 <(echo "$current_files") <(echo "$new_files") | head -5 | sed 's/^/  /'
            [[ $current_count -gt $((new_count + 5)) ]] && echo "  ... and $((current_count - new_count - 5)) more"
        else
            echo "✏️  Modified files detected"
        fi
        
        current_files="$new_files"
        current_count="$new_count"
        
        echo ""
        # Restart command (this will kill the previous one if still running)
        start_command "$@"
        echo ""
    else
        # Only check command status if no file changes (to avoid spam)
        if [[ -n "$command_pid" ]] && ! kill -0 "$command_pid" 2>/dev/null; then
            echo "⚠️  Command exited (PID: $command_pid)"
            echo "No file changes detected. Exiting watcher."
            exit 0
        fi
    fi
done

# Cleanup function
cleanup() {
    echo ""
    echo "🛑 Stopping watcher..."
    if [[ -n "$command_pid" ]]; then
        echo "Killing command (PID: $command_pid)"
        kill -TERM "$command_pid" 2>/dev/null
        wait "$command_pid" 2>/dev/null
    fi
    # Kill any background sleep processes
    jobs -p | xargs -r kill 2>/dev/null
    exit 0
}

# Set up signal handlers
trap cleanup INT TERM